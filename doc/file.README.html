<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.20
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><p><a href="https://travis-ci.org/sitrox/schemacop"><img src="https://travis-ci.org/sitrox/schemacop.svg?branch=master" alt="Build Status"></a>
<a href="https://badge.fury.io/rb/schemacop"><img src="https://badge.fury.io/rb/schemacop.svg" alt="Gem Version"></a></p>

<h1>Schemacop</h1>

<p>This is the README for Schemacop version 2, which <strong>breaks backwards
compatibility</strong> with version 1.</p>

<p>Schemacop validates ruby structures consisting of nested hashes and arrays
against schema definitions described by a simple DSL.</p>

<p>Examples:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_schema'>schema</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:naming</span><span class='comma'>,</span> <span class='symbol'>:hash</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_opt'>opt</span> <span class='symbol'>:first_name</span><span class='comma'>,</span> <span class='symbol'>:string</span>
    <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:last_name</span><span class='comma'>,</span> <span class='symbol'>:string</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:age</span><span class='comma'>,</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>18</span>
  <span class='id identifier rubyid_req?'>req?</span> <span class='symbol'>:password</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>check:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_pw'>pw</span><span class='op'>|</span> <span class='id identifier rubyid_pw'>pw</span><span class='period'>.</span><span class='id identifier rubyid_include?'>include?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>*</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='rbrace'>}</span>
    <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_schema'>schema</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span>
  <span class='label'>naming:</span> <span class='lbrace'>{</span> <span class='label'>first_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>John</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span>
            <span class='label'>last_name:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Doe</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span><span class='comma'>,</span>
  <span class='label'>age:</span> <span class='int'>34</span><span class='comma'>,</span>
  <span class='label'>password:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>my*pass</span><span class='tstring_end'>&#39;</span></span>
<span class='rparen'>)</span>
</code></pre>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_schema2'>schema2</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:description</span><span class='comma'>,</span>
      <span class='symbol'>:string</span><span class='comma'>,</span>
      <span class='label'>if:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_str'>str</span><span class='op'>|</span> <span class='id identifier rubyid_str'>str</span><span class='period'>.</span><span class='id identifier rubyid_start_with?'>start_with?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Abstract: </span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='rbrace'>}</span><span class='comma'>,</span>
      <span class='label'>max:</span> <span class='int'>35</span><span class='comma'>,</span>
      <span class='label'>check:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_str'>str</span><span class='op'>|</span> <span class='op'>!</span><span class='id identifier rubyid_str'>str</span><span class='period'>.</span><span class='id identifier rubyid_end_with?'>end_with?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>.</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='rbrace'>}</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:description</span><span class='comma'>,</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>35</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_schema2'>schema2</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='label'>description:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Abstract: a short description</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_schema2'>schema2</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='label'>description:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Since this is no abstract, we expect it to be longer.</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
</code></pre>

<h2>Installation</h2>

<p>To install the <strong>Schemacop</strong> gem:</p>

<pre class="code sh"><code class="sh">$ gem install schemacop
</code></pre>

<p>To install it using <code>bundler</code> (recommended for any application), add it to your
<code>Gemfile</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_gem'>gem</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>schemacop</span><span class='tstring_end'>&#39;</span></span>
</code></pre>

<h2>Basics</h2>

<p>Since there is no explicit typing in Ruby, it can be hard to make sure that a
method is recieving exactly the right kind of data it needs. The idea of this
gem is to define a schema at boot time that will validate the data being passed
around at runtime. Those two steps look as follows:</p>

<p>At boot time:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_schema'>my_schema</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='comment'># Your specification goes here
</span><span class='kw'>end</span>
</code></pre>

<p>At runtime:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_my_schema'>my_schema</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span>
  <span class='comment'># Your data goes here
</span><span class='rparen'>)</span>
</code></pre>

<p><code>validate!</code> will fail if the data given to it does not match what was specified
in the schema.</p>

<h3>Type lines vs. Field lines</h3>

<p>Schemacop uses a DSL (domain-specific language) to let you describe your
schemas. We distinguish between two kinds of identifiers:</p>

<ul>
<li><p>Field Lines: We call a key-value pair (like the contents of a hash) a <em>field</em>.
A field line typically starts with the keyword <code>req</code> (for a required field) or
<code>opt</code> (for an optional field).</p></li>
<li><p>Type Lines: Those start with the keyword <code>type</code> and specify the data type to
be accepted with a corresponding symbol (e.g. <code>:integer</code> or <code>:boolean</code>). You
can have multiple Type Lines for a Field Line in order to indicate that the
field&#39;s value can be of one of the specified types.</p></li>
</ul>

<p>If you don&#39;t use any short forms, a schema definition would be something like
this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:hash</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>present</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
      <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:boolean</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>The above schema would accept either an integer or a hash with exactly one field
with key &#39;present&#39; of type String and value of type Boolean (either TrueClass or
FalseClass).</p>

<p>We will see Type and Field lines in more detail below.</p>

<h3><code>validate</code> vs <code>validate!</code> vs <code>valid?</code></h3>

<p>The method <code>validate</code> will return a <code>Collector</code> object that contains all
validation errors (if any) as well as a deep copy of your data with applied
defaults and castings, whereas <code>validate!</code> will accumulate all violations
and finally throw an exception describing them or, if the validation was
successful, a deep-copy of your supplied data with defaults and castings
applied.</p>

<p>For simply querying the validity of some data, use the methods <code>valid?</code> or
<code>invalid?</code>.</p>

<p>Examples:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># validate! returns your modified data or throws a validation error
</span><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:foo</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='int'>42</span>
<span class='kw'>end</span>
<span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span> <span class='comment'># =&gt; { foo: 42 }
</span>
<span class='comment'># validate returns a collector
</span><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:foo</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='int'>42</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_collector'>collector</span> <span class='op'>=</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate'>validate</span><span class='lparen'>(</span><span class='lbrace'>{</span><span class='rbrace'>}</span><span class='rparen'>)</span> 
<span class='id identifier rubyid_collector'>collector</span><span class='period'>.</span><span class='id identifier rubyid_valid?'>valid?</span> <span class='comment'># true
</span><span class='id identifier rubyid_collector'>collector</span><span class='period'>.</span><span class='id identifier rubyid_data'>data</span>   <span class='comment'># =&gt; { foo: 42 }
</span>
<span class='id identifier rubyid_collector'>collector</span> <span class='op'>=</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate'>validate</span><span class='lparen'>(</span><span class='lbrace'>{</span> <span class='label'>foo:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>invalid</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span><span class='rparen'>)</span> 
<span class='id identifier rubyid_collector'>collector</span><span class='period'>.</span><span class='id identifier rubyid_valid?'>valid?</span>     <span class='comment'># false
</span><span class='id identifier rubyid_collector'>collector</span><span class='period'>.</span><span class='id identifier rubyid_data'>data</span>       <span class='comment'># =&gt; nil
</span><span class='id identifier rubyid_collector'>collector</span><span class='period'>.</span><span class='id identifier rubyid_exceptions'>exceptions</span> <span class='comment'># =&gt; Validation error
</span></code></pre>

<h2>Schemacop&#39;s DSL</h2>

<p>In this section, we will ignore <a href="#short-forms">short forms</a> and explicitly
write out everything.</p>

<p>Inside the block given at the schema instantiation (<code>Schema.new do ... end</code>),
the following kinds of method calls are allowed (where the outermost must be a
Type Line):</p>

<h3>Type Line</h3>

<p>A Type Line always starts with the identifier <code>type</code> and specifies a possible
data type for a given field (if inside a Field Line) or the given data structure
(if directly below the schema instantiation).</p>

<p>Type Lines are generally of the form</p>

<pre class="code ruby"><code class="ruby">type :my_type, option_1: value_1, ..., option_n: value_n
</code></pre>

<p>where <code>:my_type</code> is a supported symbol (see section <a href="#types">Types</a> below for
supported types).</p>

<h4>General options</h4>

<p>Some types support specific options that allow additional checks on the nature
of the data (such as the <code>min</code> option for type <code>:number</code>). The following options
are supported by all types:</p>

<h5>Option <code>if</code></h5>

<p>This option takes a proc (or a lambda) as value. The proc will be called when
checking whether or not the data being analyzed fits a certain type. The data is
given to the proc, which has to return either true or false. If it returns true,
the type of the given data is considered correct and the data will be validated
if further options are given.</p>

<p>Note that the proc in <code>if</code> will only get called if the type (<code>:my_type</code> from
above) fits the data already. You can use the option <code>if</code> in order to say: &quot;Even
if the data is of type <code>:my_type</code>, I consider it having the wrong type if my
proc returns false.&quot;</p>

<p>Consider a scenario in which you want to have the following rule set:</p>

<ul>
<li>Only integers may be given</li>
<li>Odd integers must be no larger than 15</li>
<li>No limitations for even integers</li>
</ul>

<p>The corresponding schema would look as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>if:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_data'>data</span><span class='op'>|</span> <span class='id identifier rubyid_data'>data</span><span class='period'>.</span><span class='id identifier rubyid_odd?'>odd?</span> <span class='rbrace'>}</span><span class='comma'>,</span> <span class='label'>max:</span> <span class='int'>15</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span>
<span class='kw'>end</span>
</code></pre>

<p>Here, the first type line will only accept odd numbers and the option <code>max: 15</code>
provided by the <code>:integer</code> validator will discard numbers higher than 15.</p>

<p>Since the first line only accepts odd numbers, it doesn&#39;t apply for even numbers
(due to the proc given to <code>if</code> they are considered to be of the wrong type) and
control falls through to the second type line accepting any integer.</p>

<h5>Option <code>check</code></h5>

<p>This option allows you to perform arbitrary custom checks for a given data type.
Just like <code>if</code>, <code>check</code> takes a proc or lambda as a value, but it runs <em>after</em>
the type checking, meaning that it only gets executed if the data has the right
type and the proc in <code>if</code> (if any) has returned true.</p>

<p>The proc passed to the <code>check</code> option is given the data being analyzed. It is to
return true if the data passes the custom check. If it returns false or an error
message as a string, Schemacop considers the data to be invalid.</p>

<p>The following example illustrates the use of the option <code>check</code>: Consider a
scenario in which you want the following rule set:</p>

<ul>
<li>Data must be of type String</li>
<li>The string must be longer than 5 characters</li>
<li>The second character must be an &#39;r&#39;</li>
</ul>

<p>The corresponding schema would look as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>5</span><span class='comma'>,</span> <span class='label'>check:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_data'>data</span><span class='op'>|</span> <span class='id identifier rubyid_data'>data</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span> <span class='op'>==</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>r</span><span class='tstring_end'>&#39;</span></span><span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>The above Type Line has type <code>:string</code> and two options (<code>min</code> and <code>check</code>). The
option <code>min</code> is supported by the <code>:string</code> validator (covered later).</p>

<p>You can also specify a custom error message by returning a string:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>check:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span><span class='period'>.</span><span class='id identifier rubyid_even?'>even?</span> <span class='op'>?</span> <span class='kw'>true</span> <span class='op'>:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Custom error</span><span class='tstring_end'>&#39;</span></span> <span class='rbrace'>}</span>
<span class='kw'>end</span>
</code></pre>

<p>This will include <code>Custom error</code> in the validation error message.</p>

<h3>Field Line</h3>

<p>Inside a Type Line of type <code>:hash</code>, you may specify an arbitrary number of field
lines (one for each key-value pair you want to be in the hash).</p>

<p>Field Lines start with one of the following six identifiers: <code>req</code>, <code>req?</code>,
<code>req!</code>, <code>opt</code>, <code>opt?</code> or <code>opt!</code>:</p>

<ul>
<li><p>The suffix <code>-!</code> means that the field must not be nil.</p></li>
<li><p>The suffix <code>-?</code> means that the field may be nil.</p></li>
<li><p>The prefix <code>req-</code> denotes a required field (validation fails if the given data
hash doesn&#39;t define it). <code>req</code> is a shorthand notation for <code>req!</code> (meaning
that by default, a required field cannot be nil).</p></li>
<li><p>The prefix <code>opt-</code> denotes an optional field. <code>opt</code> is a shorthand notation for
<code>opt?</code> (meaning that by default, an optional field may be nil).</p></li>
</ul>

<p>To summarize:</p>

<ul>
<li><code>req</code> or <code>req!</code>: required and non-nil</li>
<li><code>req?</code>: required but may be nil</li>
<li><code>opt</code> or <code>opt?</code>: optional and may be nil</li>
<li><code>opt!</code>: optional but non-nil</li>
</ul>

<p>You then pass a block with a single or multiple Type Lines to the field.</p>

<p>Example: The following schema defines a hash that has a required non-nil field
of type String under the key <code>:name</code> (of type Symbol) and an optional but
non-nil field of type Integer or Date under the key <code>:age</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:hash</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:name</span> <span class='kw'>do</span>
      <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span>
    <span class='kw'>end</span>
    <span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:age</span> <span class='kw'>do</span>
      <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span>
      <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:object</span><span class='comma'>,</span> <span class='label'>classes:</span> <span class='const'>Date</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>You might find the notation cumbersome, and you&#39;d be right to say so. Luckily
there are plenty of short forms available which we will see below.</p>

<h4>Handling hashes with indifferent access</h4>

<p>Schemacop has special handling for objects of the class
<code>ActiveSupport::HashWithIndifferentAccess</code>: You may specify the keys as symbols
or strings, and Schemacop will handle the conversion necessary for proper
validation internally. Note that if you define the same key as string and
symbol, it will throw a <code>ValidationError</code> <a href="#exceptions">exception</a> when asked to
validate a hash with indifferent access.</p>

<p>Thus, the following two schema definitions are equivalent when validating a hash
with indifferent access:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:hash</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:name</span> <span class='kw'>do</span>
      <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:hash</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>name</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
      <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h2>Types</h2>

<p>Types are defined via their validators, which is a class under <code>validator/</code>.
Each validator is sourced by <code>schemacop.rb</code>.</p>

<p>The following types are supported by Schemacop by default:</p>

<ul>
<li><p><code>:boolean</code> accepts a Ruby TrueClass or FalseClass instance.</p></li>
<li><p><code>:integer</code> accepts a Ruby Integer.</p>

<ul>
<li>supported options: <code>min</code>, <code>max</code> (lower / upper bound)</li>
</ul></li>
<li><p><code>:float</code> accepts a Ruby Float.</p>

<ul>
<li>supported options: <code>min</code>, <code>max</code> (lower / upper bound)</li>
</ul></li>
<li><p><code>:number</code> accepts a Ruby Integer or Float.</p>

<ul>
<li>supported options: <code>min</code>, <code>max</code> (lower / upper bound)</li>
</ul></li>
<li><p><code>:string</code> accepts a Ruby String.</p>

<ul>
<li>supported options: <code>min</code>, <code>max</code> (bounds for string length)</li>
</ul></li>
<li><p><code>:symbol</code> accepts a Ruby Symbol.</p></li>
<li><p><code>:object</code> accepts an arbitrary Ruby object (any object if no option is given).</p></li>
</ul>

<p>Supported options:</p>

<ul>
<li><p><code>classes</code>: Ruby class (or an array of them) that will be the only recognized
filters. Unlike other options, this one affects not the validation but the
type recognition, meaning that you can have multiple Type Lines with
different <code>classes</code> option for the same field, each having its own
validation (e.g. through the option <code>check</code>).</p></li>
<li><p><code>strict</code>: Boolean option, defaults to true. If set to false, the validator
also allows derived classes of those specified with <code>classes</code>.</p>

<ul>
<li><code>:array</code> accepts a Ruby Array.</li>
</ul></li>
<li><p>supported options: <code>min</code>, <code>max</code> (bounds for array size) and <code>nil</code>: TODO</p></li>
<li><p>accepts a block with an arbitrary number of Type Lines.</p></li>
<li><p>TODO no lookahead for different arrays, see
validator_array_test#test_multiple_arrays</p>

<ul>
<li><code>:hash</code> accepts a Ruby Hash or an <code>ActiveSupport::HashWithIndifferentAccess</code>.</li>
</ul></li>
<li><p>accepts a block with an arbitrary number of Field Lines.</p>

<ul>
<li><code>:nil</code>: accepts a Ruby NilClass instance. If you want to allow <code>nil</code> as a
value in a field, see above for the usage of the suffixes <code>-!</code> and <code>-?</code> for
Field Lines.</li>
</ul></li>
</ul>

<p>All types support the options <code>if</code> and <code>check</code> (see the section about Type Lines
above).</p>

<h2>Short forms</h2>

<p>For convenience, the following short forms may be used (and combined if
possible).</p>

<h3>Passing a type to a Field Line or schema</h3>

<p>Instead of adding a Type Line in the block of a Field Line, you can omit <code>do
type ... end</code> and directly write the type after the key of the field.</p>

<p>Note that when using this short form, you may not give a block to the Field
Line.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Long form
</span><span class='id identifier rubyid_req'>req</span> <span class='symbol'>:name</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>max:</span> <span class='int'>5</span>
<span class='kw'>end</span>

<span class='comment'># Short form
</span><span class='id identifier rubyid_req'>req</span> <span class='symbol'>:name</span><span class='comma'>,</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>max:</span> <span class='int'>5</span>
</code></pre>

<p>This means that the value under the key <code>:name</code> of type Symbol must be a String
containing 2 to 5 characters.</p>

<p>The short form also works in the schema instantiation:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Long form
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>max:</span> <span class='int'>5</span>
<span class='kw'>end</span>

<span class='comment'># Short form
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>2</span><span class='comma'>,</span> <span class='label'>max:</span> <span class='int'>5</span><span class='rparen'>)</span>
</code></pre>

<p>This means that the data given to the schema must be a String that is between 2
and 5 characters long.</p>

<h3>Passing multiple types at once</h3>

<p>You can specify several types at once by putting them in an array.</p>

<p>Note that when using this short form, you may not give any options.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Long form
</span><span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:age</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:boolean</span>
<span class='kw'>end</span>

<span class='comment'># Short form
</span><span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:age</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='lbracket'>[</span><span class='symbol'>:string</span><span class='comma'>,</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='symbol'>:boolean</span><span class='rbracket'>]</span>
<span class='kw'>end</span>
</code></pre>

<p>Combined with previous short form:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:age</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='symbol'>:string</span><span class='comma'>,</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='symbol'>:boolean</span><span class='rbracket'>]</span>
</code></pre>

<p>This also works in the schema instantiation:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='symbol'>:string</span><span class='comma'>,</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='symbol'>:boolean</span><span class='rbracket'>]</span><span class='rparen'>)</span>
</code></pre>

<p>This means that the schema will validate any data of type String, Integer,
TrueClass or FalseClass.</p>

<h3>Omitting the Type Line in a Field Line</h3>

<p>If you don&#39;t specify the type of a field, it will default to <code>:object</code> with no
options, meaning that the field will accept any kind of data:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Long form
</span><span class='id identifier rubyid_req?'>req?</span> <span class='symbol'>:child</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:object</span>
<span class='kw'>end</span>

<span class='comment'># Short form
</span><span class='id identifier rubyid_req?'>req?</span> <span class='symbol'>:child</span>
</code></pre>

<h3>Omitting the Type Line in schema instantiation</h3>

<p>If you don&#39;t give a Type Line to a schema, it will accept data of type Hash.
Therefore, if you validate Hashes only, you can omit the Type Line and directly
write Field Lines in the schema instantiation:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Long form
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:hash</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:name</span> <span class='kw'>do</span>
      <span class='comment'># ...
</span>    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='comment'># Short form
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:name</span> <span class='kw'>do</span>
    <span class='comment'># ...
</span>  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Note that this does not allow you to specify any options for the hash itself.
You still need to specify <code>:hash</code> as a type if you want to pass any options to
the hash (i.e. a <code>default</code>).</p>

<h3>Shortform for subtypes</h3>

<p>In case of nested arrays, you can group all Type Lines to a single one.</p>

<p>Note that any options or block passed to the grouped Type Line will be given to
the innermost (last) type.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Long form
</span><span class='id identifier rubyid_type'>type</span> <span class='symbol'>:array</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>3</span>
<span class='kw'>end</span>

<span class='comment'># Short form
</span><span class='id identifier rubyid_type'>type</span> <span class='symbol'>:array</span><span class='comma'>,</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>min:</span> <span class='int'>3</span>
</code></pre>

<p>A more complex example:</p>

<p>Long form:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:hash</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>nutrition</span><span class='tstring_end'>&#39;</span></span> <span class='kw'>do</span>
      <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:array</span> <span class='kw'>do</span>
        <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:array</span> <span class='kw'>do</span>
          <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:hash</span><span class='comma'>,</span> <span class='label'>check:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_h'>h</span><span class='op'>|</span> <span class='id identifier rubyid_h'>h</span><span class='period'>.</span><span class='id identifier rubyid_member?'>member?</span><span class='lparen'>(</span><span class='symbol'>:food</span><span class='rparen'>)</span> <span class='op'>||</span> <span class='id identifier rubyid_h'>h</span><span class='period'>.</span><span class='id identifier rubyid_member?'>member?</span><span class='lparen'>(</span><span class='symbol'>:drink</span><span class='rparen'>)</span> <span class='rbrace'>}</span> <span class='kw'>do</span>
            <span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:food</span> <span class='kw'>do</span>
              <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:object</span>
            <span class='kw'>end</span>
            <span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:drink</span> <span class='kw'>do</span>
              <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:object</span>
            <span class='kw'>end</span>
          <span class='kw'>end</span>
        <span class='kw'>end</span>
      <span class='kw'>end</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Short form (with this short form others from above):</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>nutrition</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='symbol'>:array</span><span class='comma'>,</span> <span class='symbol'>:array</span><span class='comma'>,</span> <span class='symbol'>:hash</span><span class='comma'>,</span> <span class='label'>check:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_h'>h</span><span class='op'>|</span> <span class='id identifier rubyid_h'>h</span><span class='period'>.</span><span class='id identifier rubyid_member?'>member?</span><span class='lparen'>(</span><span class='symbol'>:food</span><span class='rparen'>)</span> <span class='op'>||</span> <span class='id identifier rubyid_h'>h</span><span class='period'>.</span><span class='id identifier rubyid_member?'>member?</span><span class='lparen'>(</span><span class='symbol'>:drink</span><span class='rparen'>)</span> <span class='rbrace'>}</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:food</span>
    <span class='id identifier rubyid_opt!'>opt!</span> <span class='symbol'>:drink</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>This example accepts a hash with exactly one String key &#39;nutrition&#39; with value
of type Array with children of type Array with children of type Hash in which at
least one of the Symbol keys <code>:food</code> and <code>:drink</code> (with any non-nil value type)
is present.</p>

<h2>Defaults</h2>

<p>Starting from version 2.4.0, Schemacop allows you to define default values at
any point in your schema. If the validated data contains a nil value, it will be
substituted by the given default value.</p>

<p>Note that Schemacop never modifies the data you pass to it. If you want to
benefit from Schemacop-applied defaults, you need to access the cloned, modified
data returned by <code>validate</code> or <code>validate!</code>.</p>

<p>Applying defaults is done before validating the substructure and before any type
casting. The provided default will be validated same as user-supplied data, so
if your given default does not validate properly, a validation error is thrown.
Make sure your default values always match the underlying schema.</p>

<p>Defaults can be specified at any point:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># Basic usage
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Hello World</span><span class='tstring_end'>&#39;</span></span>
<span class='kw'>end</span>

<span class='comment'># The default given for the first type will match
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Hello World</span><span class='tstring_end'>&#39;</span></span> <span class='comment'># This will always be applied of no value is supplied
</span>  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='int'>42</span>
<span class='kw'>end</span>

<span class='comment'># You can also pass entire hashes or arrays to your defaults
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:foo</span><span class='comma'>,</span> <span class='symbol'>:hash</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='lbrace'>{</span> <span class='label'>foo:</span> <span class='symbol'>:bar</span> <span class='rbrace'>}</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:foo</span><span class='comma'>,</span> <span class='symbol'>:symbol</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:bar</span><span class='comma'>,</span> <span class='symbol'>:array</span><span class='comma'>,</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='lbracket'>[</span><span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span><span class='rbracket'>]</span>
<span class='kw'>end</span>

<span class='comment'># Defaults must match the given schema. The following will fail.
</span><span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:foo</span><span class='comma'>,</span> <span class='label'>default:</span> <span class='lbrace'>{</span> <span class='label'>bar:</span> <span class='symbol'>:baz</span> <span class='rbrace'>}</span> <span class='kw'>do</span>
    <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:foo</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h3>Required data points</h3>

<p>Note that any <em>required</em> validation is done before applying the defaults. If you
specify a <code>req</code> field, it must always be given, no matter if you have specified
a default or not. Therefore, specifying <code>req</code> fields do not make sense in
conjunction with defaults, as the default is always ignored.</p>

<h2>Type casting</h2>

<p>Starting from version 2.4.0, Schemacop allows you to specify type castings that
can alter the validated data. Consider the following:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_req'>req</span> <span class='symbol'>:id</span><span class='comma'>,</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>cast:</span> <span class='lbracket'>[</span><span class='const'>String</span><span class='rbracket'>]</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_data'>data</span> <span class='op'>=</span> <span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='label'>id:</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>42</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_data'>data</span> <span class='comment'># =&gt; { id: 42 }
</span></code></pre>

<p>Note that Schemacop never modifies the data you pass to it. If you want to
benefit from Schemacop-applied castings, you need to access the cloned, modified
data returned by <code>validate</code> or <code>validate!</code>.</p>

<h3>Specifying type castings</h3>

<p>Type castings can be specified using two forms: Either as a hash or as an array.
While using an array only allows you to specify the supported source types to be
casted, using a hash allows you to specify custom casting logic as blocks.</p>

<p>For hashes, the key must be a class and the value must be either <code>:default</code> for
using a built-in caster or a callable object (proc or lambda) that receives the
value and is supposed to cast it. If the value can&#39;t be casted, the proc must
fail with an exception. The exception message will then be contained in the
collected validation errors.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby">Schema.new do
  # Pass array to `cast`. This enables casting from String or Float to Integer
  # using the built-in casters.
  req: id_1, :integer, cast: [String, Float]

  # Pass hash to `cast`. This enables casting from Float to Integer using the
  # built-in caster and from String to Integer using a custom callback.
  req :id_2, :integer, cast: { Float =&gt; :default, String =&gt; proc { |s| Integer(s) }
end
</code></pre>

<h3>Built-in casters</h3>

<p>Schemacop comes with the following casters:</p>

<ul>
<li><code>String</code> to <code>Integer</code> and <code>Float</code></li>
<li><code>Float</code> to <code>Integer</code></li>
<li><code>Integer</code> to <code>Float</code></li>
</ul>

<p>Note that all built-in casters are precise, so the string <code>foo</code> will fail with
an error if casted to an Integer. When casting float values and strings
containing float values to integers, the decimal places will be discarded
however.</p>

<h3>Execution order</h3>

<p>The casting is done <em>before</em> the options <code>if</code> and <code>check</code> are evaluated.
Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='const'>Schema</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span> <span class='kw'>do</span>
  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>if:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>==</span> <span class='int'>42</span> <span class='rbrace'>}</span>    <span class='comment'># 1
</span>  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:integer</span><span class='comma'>,</span> <span class='label'>check:</span> <span class='id identifier rubyid_proc'>proc</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_i'>i</span><span class='op'>|</span> <span class='id identifier rubyid_i'>i</span> <span class='op'>&lt;</span> <span class='int'>3</span> <span class='rbrace'>}</span>   <span class='comment'># 2
</span>  <span class='id identifier rubyid_type'>type</span> <span class='symbol'>:string</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>42</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>  <span class='comment'># 1 will match
</span><span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>2</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>   <span class='comment'># 2 will match
</span><span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>234</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'># 3 will match
</span><span class='id identifier rubyid_s'>s</span><span class='period'>.</span><span class='id identifier rubyid_validate!'>validate!</span><span class='lparen'>(</span><span class='int'>5</span><span class='rparen'>)</span>     <span class='comment'># Will fail, as nothing matches
</span></code></pre>

<h3>Caveats</h3>

<p>Casting only works with type definitions that only include one type. For
instance, the <code>Numeric</code> validator includes both <code>Integer</code> and <code>Float</code>, which
would made it unclear what to cast a string into:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># This does not work, as it is unclear whether to cast the String into an
</span><span class='comment'># Integer or a Float.
</span><span class='id identifier rubyid_type'>type</span> <span class='symbol'>:number</span><span class='comma'>,</span> <span class='label'>cast:</span> <span class='lbracket'>[</span><span class='const'>String</span><span class='rbracket'>]</span>
</code></pre>

<p>The same also applies to booleans, as they compound both <code>TrueClass</code> and
<code>FalseClass</code>. This may be tackled in future releases.</p>

<h2>Exceptions</h2>

<p>Schemacop will throw one of the following checked exceptions:</p>

<ul>
<li><span class='object_link'><a href="Schemacop/Exceptions/InvalidSchemaError.html" title="Schemacop::Exceptions::InvalidSchemaError (class)">Schemacop::Exceptions::InvalidSchemaError</a></span></li>
</ul>

<p>This exception is thrown when the given schema definition format is invalid.</p>

<ul>
<li><span class='object_link'><a href="Schemacop/Exceptions/ValidationError.html" title="Schemacop::Exceptions::ValidationError (class)">Schemacop::Exceptions::ValidationError</a></span></li>
</ul>

<p>This exception is thrown when the given data does not comply with the given
  schema definition.</p>

<h2>Known limitations</h2>

<ul>
<li><p>Schemacop does not yet allow cyclic structures with infinite depth.</p></li>
<li><p>Schemacop is not made for validating complex causalities (i.e. field <code>a</code>
needs to be given only if field <code>b</code> is present).</p></li>
<li><p>Schemacop does not yet support string regex matching.</p></li>
</ul>

<h2>Development</h2>

<p>To run tests:</p>

<ul>
<li><p>Check out the source</p></li>
<li><p>Run <code>bundle install</code></p></li>
<li><p>Run <code>bundle exec rake test</code> to run all tests</p></li>
<li><p>Run <code>bundle exec rake test TEST=test/unit/some/file.rb</code> to run a single test
file</p></li>
</ul>

<h2>Copyright</h2>

<p>Copyright (c) 2019 Sitrox. See <code>LICENSE</code> for further details.</p>
</div></div>

      <div id="footer">
  Generated on Tue Nov  5 11:16:27 2019 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.20 (ruby-2.6.2).
</div>

    </div>
  </body>
</html>